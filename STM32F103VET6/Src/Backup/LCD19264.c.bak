#include "main.h"
#include "stdio.h"
#include "LCD19264.h"
uint8_t signlcd = 2;

uint8_t pic[]=
{
	/*--  横向取模 --*/
	/*--  宽度x高度=64x32  --*/
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
	0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
	0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x0C,0x00,0x00,0x0E,0x03,
	0xC0,0x00,0x0F,0xFF,0x00,0x00,0x0C,0x03,0xC0,0x03,0xF8,0x0E,0x00,0x06,0x1C,0x03,
	0xC0,0x03,0x0C,0x0E,0x00,0x0E,0x18,0x03,0xC0,0x07,0x1D,0x8C,0x00,0x0E,0x18,0x03,
	0xC0,0x06,0x3F,0xCC,0x00,0x0C,0x30,0x03,0xC0,0x06,0x77,0x1C,0x00,0x0C,0x3F,0x03,
	0xC0,0x0E,0xFE,0x18,0x00,0x1F,0xF0,0x03,0xC0,0x0D,0x9C,0x18,0x00,0x18,0x00,0x03,
	0xC0,0x0C,0x3E,0x38,0x00,0x38,0x00,0x03,0xC0,0x18,0x67,0x30,0x00,0x30,0x00,0x03,
	0xC0,0x19,0xC3,0xF0,0x00,0x71,0xF0,0x03,0xC0,0x1F,0x70,0x70,0x00,0x7F,0x70,0x03,
	0xC0,0x3C,0x30,0x70,0x00,0xE0,0xE0,0x03,0xC0,0x30,0xC0,0x60,0x00,0xC0,0xC0,0x03,
	0xC0,0x70,0xF0,0xE0,0x01,0x80,0xC0,0x03,0xC0,0x60,0x70,0xE0,0x03,0x01,0xC0,0x03,
	0xC0,0x60,0x00,0xC0,0x06,0x01,0x80,0x03,0xC0,0xFF,0xFF,0xC0,0x0C,0x03,0x80,0x03,
	0xC0,0xC0,0x07,0x80,0x38,0x03,0x80,0x03,0xC0,0xC0,0x03,0x80,0x00,0x03,0x00,0x03,
	0xC0,0x00,0x03,0x00,0x00,0x03,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
	0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
};

uint8_t font1[]=
{
	/*--  文字:  自  --*/
	/*--  黑体12;  此字体下对应的点阵为：宽x高=16x16   --*/
	0x03,0x00,0x06,0x00,0x3F,0xF8,0x3F,0xF8,0x30,0x18,0x30,0x18,0x3F,0xF8,0x30,0x18,
	0x30,0x18,0x3F,0xF8,0x30,0x18,0x30,0x18,0x3F,0xF8,0x3F,0xF8,0x30,0x18,0x00,0x00	
};
uint8_t font2[]=
{
	/*--  文字:  定  --*/
	/*--  黑体12;  此字体下对应的点阵为：宽x高=16x16   --*/
	0x01,0x80,0x01,0x80,0x7F,0xFE,0x7F,0xFE,0x60,0x06,0x1F,0xF8,0x1F,0xF8,0x01,0x80,
	0x19,0x80,0x19,0xFC,0x19,0xFC,0x39,0x80,0x3F,0x80,0x67,0xFE,0xC1,0xFE,0x00,0x00
};
uint8_t font3[]=
{
	/*--  文字:  义  --*/
	/*--  黑体12;  此字体下对应的点阵为：宽x高=16x16   --*/
	0x00,0x00,0x03,0x00,0x33,0x18,0x31,0x98,0x19,0xB0,0x18,0x30,0x08,0x60,0x0C,0x60,
	0x06,0xC0,0x03,0x80,0x03,0x80,0x06,0xC0,0x1C,0x70,0xF8,0x3E,0x60,0x0C,0x00,0x00
};
uint8_t font4[]=
{
	/*--  文字:  字  --*/
	/*--  黑体12;  此字体下对应的点阵为：宽x高=16x16   --*/
	0x03,0x00,0x01,0x80,0x7F,0xFE,0x7F,0xFE,0x60,0x06,0x1F,0xF0,0x1F,0xF0,0x00,0xC0,
	0x01,0x80,0x7F,0xFE,0x7F,0xFE,0x01,0x80,0x01,0x80,0x07,0x80,0x07,0x00,0x00,0x00
};

void Lcm_Wr_Data(uchar wrdata) //写数据
{
	CS(0);
	Lcm_Delay();
	CS(1);
	Senddata(0xFA);
	Senddata(wrdata&0xf0);
	Senddata((wrdata<<4)&0xf0);		
}


void Lcm_Wr_Command(uchar wrcommand) //写指令
{
	CS(0);
	Lcm_Delay();
	CS(1);
	Senddata(0xF8);					//			248  11111000
	Senddata(wrcommand&0xf0);			//240  11110000
	Senddata((wrcommand<<4)&0xf0);//240  11110000
}

void Senddata(uchar lcmdata)  //串口数据转换
{
	uchar i;
	if(signlcd == 2){
			for(i=0;i<8;i++)
			{
				if((lcmdata<<i)&0x80)//128 10000000
					SIO(1);
				else {
					SIO(0);
				}
				CLK(0);
				Delay_1ms(10);
				CLK(1);
				Delay_1ms(10);
				CLK2(0);
				Delay_1ms(10);
				CLK2(1);
			}
	}
	else if(signlcd == 1){
			for(i=0;i<8;i++)
			{
				if((lcmdata<<i)&0x80)//128 10000000
					SIO(1);
				else{
					SIO(0);
				}
				CLK(0);
				Delay_1ms(1);
				CLK(1);
			}
	}
	else if(signlcd == 0){
			for(i=0;i<8;i++)
			{
				if((lcmdata<<i)&0x80)//128 10000000
					SIO(1);
				else{
					SIO(0);
				}
				CLK2(0);
				Delay_1ms(1);
				CLK2(1);
			}
	}
}


/********************写DGRAM***********************
TAB是图形数据表.12864的图形显示是相当于256*32点阵.
由两屏128*32上下两屏组成，同一行的下屏的头地址紧接上屏的未地址。
绘图在串口输入时,会比在并口下的输入要慢一些
pos_x为X坐标，每进1位右移16个点,从0开始
pos_y为Y坐标，每进1位下移1个点,从0开始
****************************************************/
void Wr_Gdram(uchar pos_x,uchar pos_y,uint length,uchar width,uchar *table)
{	 
	uchar i,j;
	Lcm_Wr_Command(0x34);//选择扩充指令	
	Lcm_Wr_Command(0x36);	
	for(j=pos_y;j<pos_y+width;j++)
	{	
		Lcm_Wr_Command(0x80+j);  //Y总坐标,即第几行
		Lcm_Wr_Command(0x80+pos_x);//X坐标，16个点进1
		for(i=0;i<length/8;i++)//
			Lcm_Wr_Data(*table++);
	}		
	Lcm_Wr_Command(0x30);//返回基本指令
}

void Wr_Gdram1(uchar pos_x,uchar pos_y,uint length,uchar width)
{	 
	uchar i,j;
	Lcm_Wr_Command(0x34);//选择扩充指令	
	Lcm_Wr_Command(0x36);	
	for(j=pos_y;j<pos_y+width;j++)
	{	
		Lcm_Wr_Command(0x80+j);  //Y总坐标,即第几行
		Lcm_Wr_Command(0x80+pos_x);//X坐标，16个点进1
		for(i=0;i<length/8;i++)//
			Lcm_Wr_Data(0xff);
	}		
	Lcm_Wr_Command(0x30);//返回基本指令
}

//清除GDRAM
void Clean_Gdram(void)
{    
	uchar i,j;
	Lcm_Wr_Command(0x34);	
    for(j=0;j<32;j++)
    {
       Lcm_Wr_Command(0x80+j);
	   Lcm_Wr_Command(0x80);
       for(i=0;i<32;i++)//
       		Lcm_Wr_Data(0);
    }
	Lcm_Wr_Command(0x36);		
	Lcm_Wr_Command(0x30);	
}


/***************************************************
	自定义字符写入CGRAM
	总共有4个自定义字符
	写入地址				   0x40   0x50   0x60   0x70
	对应的读出地址为    0x00   0x02   0x04   0x06
****************************************************/
void Wr_Cgram(uchar addr,uchar *table)
{     
      uchar i;
	  Lcm_Wr_Command(addr);  	//设定CGRAM地址	  
      for(i=0;i<32;i++)
		  Lcm_Wr_Data(*table++); 
}



//选定坐标
void Lcm_GotoXY(uchar pos_X,uchar pos_y,uchar sign)
{ /**
		*139是第二栏最后一位 ---- 8b
		*155是第二栏最后一位 ---- 9b
		*/
	signlcd = sign;
	uchar addr;
	if((pos_X>32)||(pos_y>3))
		return;
	
	if(pos_y==0)
		addr=0x80+pos_X;
	else if(pos_y==1)
		addr=0x90+pos_X; 
	else if(pos_y==2)
		addr=0x8b+pos_X;	
	else if(pos_y==3)
		addr=0x9b+pos_X;	
	Lcm_Wr_Command(addr);//设定DDRAM地址
}


void Lcm_Disp_Onechar(uchar onechar)//显示单个字符
{
	Lcm_Wr_Data(onechar);	
}


void Disp_Cgram(uchar addr_data)//显示自定义的字符
{
	Lcm_Wr_Data(0x00);
    Lcm_Wr_Data(addr_data);	
}


void Lcm_Disp_String(uchar *string)//显示字符串
{ 
	while (*string != '\0')
		Lcm_Wr_Data(*string++);
}


void Lcm_Init(void)
{
	CS(1);
	SIO(0);
	CLK(0);
	Delay_1ms(10);
	CLK2(0);
	//PSB=0;
	//RST=1;
	//RST=0;
	Delay_1ms(10);
	//RST=1;

	Lcm_Wr_Command(0x30);
	Delay_1ms(5);
	Lcm_Wr_Command(0x30); 
	Delay_1ms(5);
	Lcm_Wr_Command(0x0c); //开显示及光标设置
	Delay_1ms(5);
	Lcm_Wr_Command(0x01); //显示清屏
	Delay_1ms(10);
	Lcm_Wr_Command(0x06); //显示光标移动设置
	Delay_1ms(5);
}


void Delay_1ms(uint x)//1ms延时
{
	unsigned char j;
	while(x--)
	{
		for(j=0;j<125;j++)
		{;}
	}
}


void Lcm_Delay(void)
{	
/*	_nop_();
	_nop_();
	_nop_();
	_nop_();
	_nop_();
	_nop_();
	_nop_();
	_nop_();
	*/
}


//整行反白显示
//0：第一行
//1：第一行
//2：第一行
//3：第一行

void CLK(unsigned char State){
	if(State == 0){
		HAL_GPIO_WritePin(LCD_CLK_GPIO_Port,LCD_CLK_Pin,GPIO_PIN_RESET);
	}
	else
		HAL_GPIO_WritePin(LCD_CLK_GPIO_Port,LCD_CLK_Pin,GPIO_PIN_SET);
}

void CLK2(unsigned char State){
	if(State == 0){
		HAL_GPIO_WritePin(LCD_CLK2_GPIO_Port,LCD_CLK2_Pin,GPIO_PIN_RESET);
	}
	else
		HAL_GPIO_WritePin(LCD_CLK2_GPIO_Port,LCD_CLK2_Pin,GPIO_PIN_SET);
}

void SIO(unsigned char State){
	if(State == 0){
		HAL_GPIO_WritePin(LCD_SIO_GPIO_Port,LCD_SIO_Pin,GPIO_PIN_RESET);
	}
	else
		HAL_GPIO_WritePin(LCD_SIO_GPIO_Port,LCD_SIO_Pin,GPIO_PIN_SET);
}

void CS(unsigned char State){
	if(State == 0){
		HAL_GPIO_WritePin(LCD_STB_GPIO_Port,LCD_STB_Pin,GPIO_PIN_RESET);
	}
	else
		HAL_GPIO_WritePin(LCD_STB_GPIO_Port,LCD_STB_Pin,GPIO_PIN_SET);
}




